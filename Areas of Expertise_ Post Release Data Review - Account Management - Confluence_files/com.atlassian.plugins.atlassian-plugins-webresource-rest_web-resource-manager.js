WRMCB=function(e){var c=console;if(c&&c.log&&c.error){c.log('Error running batched script.');c.error(e);}}
;
try {
/* module-key = 'com.atlassian.plugins.atlassian-plugins-webresource-rest:web-resource-manager', location = 'js/dist/wrm.js' */
!function(){"use strict";const e=window.WRM.contextPath,r={debug:1,info:2,log:3,warn:4,error:5};let t="log";const n=(e,n)=>(...s)=>{r[e]>=(r[t]||r.log)&&console[e](...n,...s)},s=({context:e="default"})=>{const t=["[WRM]",`[${e}]`];return Object.keys(r).reduce(((e,r)=>Object.assign(Object.assign({},e),{[r]:n(r,t)})),{})},i=s({context:"tracker"}),o="data-wrm-key",a="data-wrm-batch-type",u={resource:"wr!",context:"wrc!"},c=e=>e.length>0&&"-"!==e[0];class d{constructor(e){this._container=e,this._initialized=!1,this._resourceKeys=new Set}_getLoaded(){return Array.from(this._resourceKeys)}getResources(){return!0===this._initialized||(this._container.querySelectorAll("[data-wrm-key][data-wrm-batch-type]").forEach((e=>{"SCRIPT"!==e.nodeName&&"LINK"!==e.nodeName||this.addResource(e.getAttribute(o),e.getAttribute(a))})),this._initialized=!0),this._getLoaded()}addResource(e,r){const t="string"==typeof r?r.toLowerCase():r;if(!Object.keys(u).includes(t))return void i.log("Unknown batch type",r);const n=u[t];e.split(",").filter(c).forEach((e=>{this._resourceKeys.add(`${n}${e}`)}))}}const l=s({context:"queue"}),h=e=>{const r=[];return{enqueue:(t,n)=>new Promise(((s,i)=>{l.debug("Resources entering the queue... ",{resourceKeys:t,phase:e}),r.push({phase:e,resourceKeys:t,resolve:s,reject:i}),n()})),isNotEmpty:()=>r.length>0,drain:()=>{const e=[...r];return r.length=0,e}}},g=e=>({result:r,queuedElements:t})=>Promise.all(t.map((t=>t[e](r)))),p=e=>{const r={require:h("require"),interaction:h("interaction")},t=[r.require],n=()=>Promise.all(t.flatMap((e=>e.drain()))),s=()=>{t.some((e=>e.isNotEmpty()))?(l.debug("There are resources waiting in queue: ",r),i?l.debug("Draining already scheduled"):(l.debug("Scheduling next draining"),i=Promise.resolve().then(n).then(e).then(g("resolve"),g("reject")).finally((()=>{l.debug("Resources from drained queues processed"),i=void 0,s()})))):l.debug("Nothing waiting in queue. Draining won't be scheduled this time.")};var i;return(e=>{switch(document.readyState){case"interactive":case"complete":e();break;default:l.debug("Registering DCL event listener"),document.addEventListener("DOMContentLoaded",e,{once:!0})}})((()=>{t.push(r.interaction),s()})),{enqueue:(e,t)=>r[t].enqueue(e,s)}},m="JS",y="CSS",f=e=>(document.head.appendChild(e),new Promise(((r,t)=>{e.addEventListener("load",r),e.addEventListener("error",t)}))),R=e=>{const[r,t]=e.split("!");return"js"===r?(e=>{const r=document.createElement("script");return r.src=e,r.async=!1,f(r)})(t):"css"===r?(e=>{const r=document.createElement("link");return r.href=e,r.rel="stylesheet",f(r)})(t):Promise.reject(new Error("Unsupported resource identifier"))},q=1,b=2,_=4,w=8,v=s({context:"handler"}),M=()=>{};function P(e){v.warn("asynchronously loading a CSS resource containing a media query",e.url);var r=document.createElement("link");r.setAttribute("rel","stylesheet"),r.setAttribute("type","text/css"),r.setAttribute("href",e.url),r.setAttribute("media",e.media),document.head.appendChild(r)}function W(e){return Boolean(document.querySelector(`script[src='${e}']`))}function E(e){return Boolean(document.querySelector(`link[href='${e}']`))}function k(e,r){return e.filter((e=>e.phase===r)).flatMap((e=>e.resourceKeys))}"curl"in WRM||(WRM.curl=()=>{v.error("WRM.curl is deprecated. Use WRM.require instead. See https://bitbucket.org/atlassian/atlassian-plugins-webresource/src/master/UPGRADE_500.md")});const j=e=>e.join(","),A=e=>{const r=window.WRM.__localeOverride;if(void 0===r)return e;if("string"!=typeof r||""===r.trim())return v.warn("Locale override failed. The window.WRM.__localeOverride should either be undefined or a non-empty, non-blank string."),e;try{const t=new URL(e);return t.searchParams.set("locale",r),v.warn("Resource locale is overriden by window.WRM.__localeOverride: ",r),t.toString()}catch(r){return v.warn("Locale override failed. Invalid resource URL. Falling back to the default locale."),e}};const L=new class{constructor(){this._requireCache={"":Promise.resolve()},this._queueManager=p(this._getScriptsForResources.bind(this)),this._tracker=new d(document)}_genericRequire(e,r,t){const n=[].concat(e).filter((e=>"string"==typeof e&&e.trim().length>0)),s=j(n);this._requireCache.hasOwnProperty(s)||(this._requireCache[s]=new Promise(((e,r)=>{this._resolveAsync(n,t.phase).then(e,r)})));const i=(e=>{const r=e;let t="pending";return r.state=()=>t,r.done=n=>(e.then((()=>(t="resolved",n())),M),r),r.fail=n=>(e.catch((e=>(t="rejected",n.apply(void 0,e)))),r),r.always=t=>(e.finally(t),r),r.promise=()=>r,r.progress=()=>r,r})(this._requireCache[s]);return"function"==typeof r&&i.done(r),i}require(e,r){return this._genericRequire(e,r,{phase:"require"})}requireLazily(e,r){return this._genericRequire(e,r,{phase:"interaction"})}_resolveAsync(e,r){return this._queueManager.enqueue(e,r).catch((([r,t])=>{if(r!==b){const r=j(e);delete this._requireCache[r]}return Promise.reject(t)}))}_processResourceResponse({unparsedData:e,unparsedErrors:r,resources:t}){if(e&&(WRM._unparsedData||(WRM._unparsedData={}),Object.assign(WRM._unparsedData,e),WRM._dataArrived()),r&&(WRM._unparsedErrors||(WRM._unparsedErrors={}),Object.assign(WRM._unparsedErrors,r),WRM._dataArrived()),!t.length)return v.debug("There is nothing to be requested by resource-loader"),Promise.resolve();const n=[],s=[];for(let e of t){const r=A(e.url);this._tracker.addResource(e.key,e.batchType),e.resourceType===m?W(r)||n.push(`js!${r}`):e.resourceType===y?E(r)||(e.media&&"all"!==e.media?s.push(e):n.push(`css!${r}`)):v.log("Unknown resource type required",r)}return v.log("Downloading resources",n),new Promise((function(e,r){var t,i,o;v.debug("resource-loader requesting resources: ",n),t=n,i=(...r)=>{s.forEach(P),v.debug("resource-loader resolves",r),e(r)},o=(...e)=>{v.debug("resource-loader fails",e),r(e)},Promise.all(t.map(R)).then(i,o)}))}_getScriptsForResources(r){if(0===r.length)return v.debug("Nothing to request from WRM API"),Promise.resolve({result:void 0,queuedElements:r});const t=JSON.stringify({require:k(r,"require"),interaction:k(r,"interaction"),exclude:this._tracker.getResources()});return v.debug("Payload for WRM API call prepared: ",t),new Promise(((n,s)=>{let i;const o=e=>r=>(i=i||[e,r],Promise.reject());v.debug("Calling WRM API..."),fetch(e()+"/rest/wrm/2.0/resources",{method:"POST",cache:"no-cache",credentials:"same-origin",mode:"same-origin",headers:{"Content-Type":"application/json"},body:t}).then((e=>e.ok?e.json():Promise.reject(e)),o(_)).then((({require:e,interaction:r})=>{v.debug("WRM API responded: ",{require:e,interaction:r});return(()=>this._processResourceResponse(e))().then((()=>this._processResourceResponse(r)))}),o(q)).then((e=>n({result:e,queuedElements:r})),o(b)).catch((e=>{const t=e?[w,e]:i;v.debug("WRM API call failed",t),s({result:t,queuedElements:r})}))}))}},S=e=>(r,t)=>L[e](r,t),C=S("require"),O=S("requireLazily");WRM.require=C,WRM.requireLazily=O,WRM.setLoggingLevel=e=>{t=e},"function"==typeof define&&(define("wrm/require",(()=>C)),define("wrm/require-lazily",(()=>O)),define("wrm",(()=>WRM)))}();

}catch(e){WRMCB(e)};