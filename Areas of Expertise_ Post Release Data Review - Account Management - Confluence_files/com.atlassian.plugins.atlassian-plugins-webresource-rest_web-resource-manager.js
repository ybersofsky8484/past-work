WRMCB=function(e){var c=console;if(c&&c.log&&c.error){c.log('Error running batched script.');c.error(e);}}
;
try {
/* module-key = 'com.atlassian.plugins.atlassian-plugins-webresource-rest:web-resource-manager', location = 'js/dist/wrm.js' */
!function(){"use strict";const e=window.WRM.contextPath,r={debug:1,info:2,log:3,warn:4,error:5};let t="log";const n=(e,n)=>(...s)=>{r[e]>=(r[t]||r.log)&&console[e](...n,...s)},s=({context:e="default"})=>{const t=["[WRM]",`[${e}]`];return Object.keys(r).reduce(((e,r)=>Object.assign(Object.assign({},e),{[r]:n(r,t)})),{})},i=e=>{t=e},o=s({context:"tracker"}),a={resource:"wr!",context:"wrc!"},u=e=>e.length>0&&"-"!==e[0];class c{constructor(e){this._container=e,this._initialized=!1,this._resourceKeys=new Set}_getLoaded(){return Array.from(this._resourceKeys)}getResources(){return this._initialized||(this._container.querySelectorAll("[data-initially-rendered]").forEach((e=>{var r,t;"SCRIPT"!==e.nodeName&&"LINK"!==e.nodeName||this.addResource(null!==(r=e.getAttribute("data-wrm-key"))&&void 0!==r?r:"",null!==(t=e.getAttribute("data-wrm-batch-type"))&&void 0!==t?t:"")})),this._initialized=!0),this._getLoaded()}addResource(e,r){const t=r.toLowerCase();if(!Object.keys(a).includes(t)){const t=`Unknown batch type '${r}' discovered when adding a resource '${e}'`;throw o.error(t),new Error(t)}const n=a[t];e.split(",").filter(u).forEach((e=>{this._resourceKeys.add(`${n}${e}`)}))}}const d=s({context:"queue"}),l=e=>{const r=[];return{enqueue:(t,n)=>new Promise(((s,i)=>{d.debug("Resources entering the queue... ",{resourceKeys:t,phase:e}),r.push({phase:e,resourceKeys:t,resolve:s,reject:i}),n()})),isNotEmpty:()=>r.length>0,drain:()=>{const e=[...r];return r.length=0,e}}},h=e=>({result:r,queuedElements:t})=>Promise.all(t.map((t=>t[e](r)))),g=e=>{const r={require:l("require"),interaction:l("interaction")},t=[],n=()=>Promise.all(t.flatMap((e=>e.drain()))),s=()=>{t.some((e=>e.isNotEmpty()))?(d.debug("There are resources waiting in queue: ",r),i?d.debug("Draining already scheduled"):(d.debug("Scheduling next draining"),i=Promise.resolve().then(n).then(e).then(h("resolve"),h("reject")).finally((()=>{d.debug("Resources from drained queues processed"),i=void 0,s()})))):d.debug("Nothing waiting in queue. Draining won't be scheduled this time.")};var i;switch(document.readyState){default:d.error("There's a missing readyState, fix it ASAP! No guarantees the page will ever work nor load");case"loading":document.addEventListener("DOMContentLoaded",(()=>{t.push(r.interaction),s()}),{once:!0}),document.addEventListener("readystatechange",(()=>{"interactive"===document.readyState&&(t.push(r.require),s())}),{once:!0});break;case"interactive":document.addEventListener("DOMContentLoaded",(()=>{t.push(r.interaction),s()}),{once:!0}),t.push(r.require),s();break;case"complete":t.push(r.require),t.push(r.interaction),s()}return console.debug(`[WRM] Client-side initialised during '${document.readyState}' state`),{enqueue:(e,t)=>r[t].enqueue(e,s)}},p="JS",m="CSS",y=e=>(document.head.appendChild(e),new Promise(((r,t)=>{e.addEventListener("load",r),e.addEventListener("error",t)}))),f=e=>{const[r,t]=e.split("!");return"js"===r?(e=>{const r=document.createElement("script");return r.src=e,r.async=!1,r.defer=!0,y(r)})(t):"css"===r?(e=>{const r=document.createElement("link");return r.href=e,r.rel="stylesheet",y(r)})(t):Promise.reject(new Error("Unsupported resource identifier"))},q=1,R=2,w=4,b=8,_=s({context:"handler"}),v=()=>{};function M(e){_.warn("asynchronously loading a CSS resource containing a media query",e.url);var r=document.createElement("link");r.setAttribute("rel","stylesheet"),r.setAttribute("type","text/css"),r.setAttribute("href",e.url),r.setAttribute("media",e.media),document.head.appendChild(r)}function P(e){return Boolean(document.querySelector(`script[src='${e}']`))}function W(e){return Boolean(document.querySelector(`link[href='${e}']`))}function E(e,r){return e.filter((e=>e.phase===r)).flatMap((e=>e.resourceKeys))}"curl"in WRM||(WRM.curl=()=>{_.error("WRM.curl is deprecated. Use WRM.require instead. See https://bitbucket.org/atlassian/atlassian-plugins-webresource/src/master/UPGRADE_500.md")});const S=e=>e.join(","),k=e=>{const r=window.WRM.__localeOverride;if(void 0===r)return e;if("string"!=typeof r||""===r.trim())return _.warn("Locale override failed. The window.WRM.__localeOverride should either be undefined or a non-empty, non-blank string."),e;try{const t=new URL(e);return t.searchParams.set("locale",r),_.warn("Resource locale is overriden by window.WRM.__localeOverride: ",r),t.toString()}catch(r){return _.warn("Locale override failed. Invalid resource URL. Falling back to the default locale."),e}};const A=new class{constructor(){this._requireCache={"":Promise.resolve()},this._queueManager=g(this._getScriptsForResources.bind(this)),this._tracker=new c(document)}_genericRequire(e,r,t){const n=[].concat(e).filter((e=>"string"==typeof e&&e.trim().length>0)),s=S(n);this._requireCache.hasOwnProperty(s)||(this._requireCache[s]=new Promise(((e,r)=>{this._resolveAsync(n,t.phase).then(e,r)})));const i=(e=>{const r=e;let t="pending";return r.state=()=>t,r.done=n=>(e.then((()=>(t="resolved",n())),v),r),r.fail=n=>(e.catch((e=>(t="rejected",n.apply(void 0,e)))),r),r.always=t=>(e.finally(t),r),r.promise=()=>r,r.progress=()=>r,r})(this._requireCache[s]);return"function"==typeof r&&i.done(r),i}require(e,r){return this._genericRequire(e,r,{phase:"require"})}requireLazily(e,r){return this._genericRequire(e,r,{phase:"interaction"})}_resolveAsync(e,r){return this._queueManager.enqueue(e,r).catch((([r,t])=>{if(r!==R){const r=S(e);delete this._requireCache[r]}return Promise.reject(t)}))}_processResourceResponse({unparsedData:e,unparsedErrors:r,resources:t}){if(e&&(WRM._unparsedData||(WRM._unparsedData={}),Object.assign(WRM._unparsedData,e),WRM._dataArrived()),r&&(WRM._unparsedErrors||(WRM._unparsedErrors={}),Object.assign(WRM._unparsedErrors,r),WRM._dataArrived()),!t.length)return _.debug("There is nothing to be requested by resource-loader"),Promise.resolve();const n=[],s=[];for(let e of t){const r=k(e.url);this._tracker.addResource(e.key,e.batchType),e.resourceType===p?P(r)||n.push(`js!${r}`):e.resourceType===m?W(r)||(e.media&&"all"!==e.media?s.push(e):n.push(`css!${r}`)):_.log("Unknown resource type required",r)}return _.log("Downloading resources",n),new Promise((function(e,r){var t,i,o;_.debug("resource-loader requesting resources: ",n),t=n,i=(...r)=>{s.forEach(M),_.debug("resource-loader resolves",r),e(r)},o=(...e)=>{_.debug("resource-loader fails",e),r(e)},Promise.all(t.map(f)).then(i,o)}))}_getScriptsForResources(r){if(0===r.length)return _.debug("Nothing to request from WRM API"),Promise.resolve({result:void 0,queuedElements:r});const t={require:E(r,"require"),interaction:E(r,"interaction"),exclude:this._tracker.getResources()};return _.debug("Payload for WRM API call prepared: ",t),new Promise(((n,s)=>{let i;const o=e=>r=>(i=i||[e,r],Promise.reject());_.debug("Calling WRM API..."),fetch(e()+"/rest/wrm/2.0/resources",{method:"POST",cache:"no-cache",credentials:"same-origin",mode:"same-origin",headers:{"Content-Type":"application/json"},body:JSON.stringify(t)}).then((e=>e.ok?e.json():Promise.reject(e)),o(w)).then((({require:e,interaction:r})=>{_.debug("WRM API responded: ",{require:e,interaction:r});return(()=>this._processResourceResponse(e))().then((()=>this._processResourceResponse(r)))}),o(q)).then((e=>n({result:e,queuedElements:r})),o(R)).catch((e=>{const t=e?[b,e]:i;_.debug("WRM API call failed",t),s({result:t,queuedElements:r})}))}))}},L=e=>(r,t)=>A[e](r,t),j=L("require"),C=L("requireLazily");WRM.require=j,WRM.requireLazily=C,WRM.setLoggingLevel=i,"function"==typeof define&&(define("wrm/require",(()=>j)),define("wrm/require-lazily",(()=>C)),define("wrm/set-logging-level",(()=>i)),define("wrm",(()=>WRM)))}();

}catch(e){WRMCB(e)};